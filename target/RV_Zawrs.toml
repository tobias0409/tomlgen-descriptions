set = "RVZawrs"
width = 32

[formats]
names = [
    "format-1-0",
]
parts = [
    [
        "none",
        32,
        "u32",
    ],
    [
        "imm",
        32,
        "VInt",
    ],
    [
        "himm",
        32,
        "VInt",
        "hex",
    ],
]

[types]
names = [
    "type-1-0",
]
type-1-0 = [
    { name = "none", top = 31, bot = 0 },
]

[format-1-0]
type = "type-1-0"

[format-1-0.repr]
default = "$name$"

[format-1-0.instructions."wrs.nto"]
mask = 4294967295
match = 13631603
description = "To mitigate the wasteful looping in such usages, a `wrs.nto` (WRS-with-no-timeout) instruction is provided.\nInstead of polling for a store to a specific memory location, software registers a reservation set that\nincludes all the bytes of the memory location using the LR instruction. Then a subsequent `wrs.nto`\ninstruction would cause the hart to temporarily stall execution in a low-power state until a store\noccurs to the reservation set or an interrupt is observed.\n\nThis instruction is not supported in a constrained LR/SC loop.\nWhile stalled, an implementation is permitted to occasionally terminate the stall and complete\nexecution for any reason.\n\n`wrs.nto` follows the rules of the WFI instruction for resuming execution\non a pending interrupt.\n\nWhen the TW (Timeout Wait) bit in `mstatus` is set and `wrs.nto` is executed\nin any privilege mode otherthan M mode, and it does not complete within an implementation-specific\nbounded time limit, the `wrs.nto` instruction will cause an illegal instruction exception.\n\nWhen executing in VS or VU mode, if the VTW bit is set in `hstatus`, the TW bit in `mstatus` is clear,\nand the `wrs.nto` does not complete within an implementation-specific bounded time limit,\nthe `wrs.nto` instruction will cause a virtual instruction exception.\n\n[Note]\nSince `wrs.nto` can complete execution for reasons other than stores to the reservation set,\nsoftware will likely need a means of looping until the required stores have occurred.\n\n[Note]\n`wrs.nto`, unlike WFI, is not specified to cause an illegal instruction exception if executed in U-mode\nwhen the governing TW bit is 0. WFI is typically not expected to be used in U-mode and on many systems\nmay promptly cause an illegal instruction exception if used at U-mode.\nUnlike WFI, `wrs.nto` is expected to be used by software in U-mode when waiting on memory but without\na deadline for that wait.\n"

[format-1-0.instructions."wrs.sto"]
mask = 4294967295
match = 30408819
description = "Instead of polling for a store to a specific memory location, software registers a\nreservation set that includes all the bytes of the memory location using the LR instruction.\nA subsequent `wrs.sto` instruction would cause the hart to temporarily stall execution in a\nlow-power state until a store occurs to the reservation set or an interrupt is observed.\nSometimes the program waiting on a memory update may also need to carry out a task at a future time\nor otherwise place an upper bound on the wait. To support such use cases, `wrs.sto` bounds the\nstall duration to an implementation-define short timeout such that the stall is terminated on the\ntimeout if no other conditions have occurred to terminate the stall. The program using this instruction\nmay then determine if its deadline has been reached.\n`wrs.sto` causes the hart to temporarily stall execution in a low-power state as long as the reservation\nset is valid and no pending interrupts, even if disabled, are observed. For `wrs.sto` the stall duration\nis bounded by an implementation defined short timeout. These instructions are not supported in a\nconstrained LR/SC loop.\nHart execution may be stalled while the following conditions are all satisfied:\na. The reservation set is valid\nb. If `wrs.sto`, a \"short\" duration since start of stall has not elapsed\nc. No pending interrupt is observed (see the rules below)\n\nWhile stalled, an implementation is permitted to occasionally terminate the stall and complete\nexecution for any reason. `wrs.sto` follows the rules of the WFI instruction for resuming execution\non a pending interrupt. Since `wrs.sto` can complete execution for reasons other than stores to\nthe reservation set, software will likely need a means of looping until the required stores have occurred.\n\n[Note]\nThe duration of a `wrs.sto` instruction's timeout may vary significantly within and among implementations.\nIn typical implementations this duration should be roughly in the range of 10 to 100 times an on-chip\ncache miss latency or a cacheless access to main memory.\n"

[mappings]
names = []
number = 32
