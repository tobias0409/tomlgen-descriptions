set = "RV32A"
width = 32

[formats]
names = [
    "format_1-0",
    "format_2-0",
]
parts = [
    [
        "rd_Register_int",
        5,
        "Register_int",
    ],
    [
        "rd_Register_float",
        5,
        "Register_float",
    ],
    [
        "rs1_Register_int",
        5,
        "Register_int",
    ],
    [
        "rs1_Register_float",
        5,
        "Register_float",
    ],
    [
        "rs2_Register_int",
        5,
        "Register_int",
    ],
    [
        "rs2_Register_float",
        5,
        "Register_float",
    ],
    [
        "aqrl",
        2,
        "Mapping_ordering",
    ],
    [
        "none",
        32,
        "u32",
    ],
    [
        "imm",
        32,
        "VInt",
    ],
    [
        "himm",
        32,
        "VInt",
        "hex",
    ],
]

[types]
names = [
    "type_1-0",
    "type_2-0",
]
type_1-0 = [
    { name = "none", top = 31, bot = 27 },
    { name = "aqrl", top = 1, bot = 0 },
    { name = "rs2_Register_int", top = 4, bot = 0 },
    { name = "rs1_Register_int", top = 4, bot = 0 },
    { name = "none", top = 14, bot = 12 },
    { name = "rd_Register_int", top = 4, bot = 0 },
    { name = "none", top = 6, bot = 0 },
]
type_2-0 = [
    { name = "none", top = 31, bot = 27 },
    { name = "aqrl", top = 1, bot = 0 },
    { name = "none", top = 24, bot = 20 },
    { name = "rs1_Register_int", top = 4, bot = 0 },
    { name = "none", top = 14, bot = 12 },
    { name = "rd_Register_int", top = 4, bot = 0 },
    { name = "none", top = 6, bot = 0 },
]

[format_1-0]
type = "type_1-0"

[format_1-0.repr]
default = "$name$%aqrl% %rd_Register_int%, %rs2_Register_int%, (%rs1_Register_int%)"

[format_1-0.instructions."amoadd.w"]
mask = 4160778367
match = 8239
description = "Atomically:\n\n  * Load the word at address _xs1_\n  * Write the sign-extended value into _xd_\n  * Add the least-significant word of register _xs2_ to the loaded value\n  * Write the sum to the address in _xs1_\n"

[format_1-0.instructions."amoand.w"]
mask = 4160778367
match = 1610620975
description = "Atomically:\n\n  * Load the word at address _xs1_\n  * Write the sign-extended value into _xd_\n  * AND the least-significant word of register _xs2_ to the loaded value\n  * Write the result to the address in _xs1_\n"

[format_1-0.instructions."amomax.w"]
mask = 4160778367
match = 2684362799
description = "Atomically:\n\n  * Load the word at address _xs1_\n  * Write the sign-extended value into _xd_\n  * Signed compare the least-significant word of register _xs2_ to the loaded value, and select the maximum value\n  * Write the maximum to the address in _xs1_\n"

[format_1-0.instructions."amomaxu.w"]
mask = 4160778367
match = 3758104623
description = "Atomically:\n\n  * Load the word at address _xs1_\n  * Write the sign-extended value into _xd_\n  * Unsigned compare the least-significant word of register _xs2_ to the loaded value, and select the maximum value\n  * Write the maximum to the address in _xs1_\n"

[format_1-0.instructions."amomin.w"]
mask = 4160778367
match = 2147491887
description = "Atomically:\n\n  * Load the word at address _xs1_\n  * Write the sign-extended value into _xd_\n  * Signed compare the least-significant word of register _xs2_ to the loaded value, and select the minimum value\n  * Write the result to the address in _xs1_\n"

[format_1-0.instructions."amominu.w"]
mask = 4160778367
match = 3221233711
description = "Atomically:\n\n  * Load the word at address _xs1_\n  * Write the sign-extended value into _xd_\n  * Unsigned compare the least-significant word of register _xs2_ to the loaded word, and select the minimum value\n  * Write the result to the address in _xs1_\n"

[format_1-0.instructions."amoor.w"]
mask = 4160778367
match = 1073750063
description = "Atomically:\n\n  * Load the word at address _xs1_\n  * Write the sign-extended value into _xd_\n  * OR the least-significant word of register _xs2_ to the loaded value\n  * Write the result to the address in _xs1_\n"

[format_1-0.instructions."amoswap.w"]
mask = 4160778367
match = 134225967
description = "Atomically:\n\n  * Load the word at address _xs1_\n  * Write the sign-extended value into _xd_\n  * Store the least-significant word of register _xs2_ to the address in _xs1_\n"

[format_1-0.instructions."amoxor.w"]
mask = 4160778367
match = 536879151
description = "Atomically:\n\n  * Load the word at address _xs1_\n  * Write the sign-extended value into _xd_\n  * XOR the least-significant word of register _xs2_ to the loaded value\n  * Write the result to the address in _xs1_\n"

[format_1-0.instructions."sc.w"]
mask = 4160778367
match = 402661423
description = "`sc.w` conditionally writes a word in _xs2_ to the address in _xs1_:\nthe `sc.w` succeeds only if the reservation is still valid and the\nreservation set contains the bytes being written. If the `sc.w` succeeds,\nthe instruction writes the word in _xs2_ to memory, and it writes zero to _xd_.\nIf the `sc.w` fails, the instruction does not write to memory, and it writes a\nnonzero value to _xd_. For the purposes of memory protection, a failed `sc.w`\nmay be treated like a store. Regardless of success or failure, executing an\n`sc.w` instruction invalidates any reservation held by this hart.\n\n<%- if MXLEN == 64 -%>\n[NOTE]\nIf a value other than 0 or 1 is defined as a result for `sc.w`, the value will before\nsign-extended into _xd_.\n<%- end -%>\n\nThe failure code with value 1 encodes an unspecified failure.\nOther failure codes are reserved at this time.\nPortable software should only assume the failure code will be non-zero.\n\nThe address held in _xs1_ must be naturally aligned to the size of the operand\n(_i.e._, eight-byte aligned for doublewords and four-byte aligned for words).\nIf the address is not naturally aligned, an address-misaligned exception or an\naccess-fault exception will be generated.\nThe access-fault exception can be generated for a memory access that would otherwise\nbe able to complete except for the misalignment,\nif the misaligned access should not be emulated.\n\n[NOTE]\n--\nEmulating misaligned LR/SC sequences is impractical in most systems.\n\nMisaligned LR/SC sequences also raise the possibility of accessing multiple\nreservation sets at once, which present definitions do not provide for.\n--\n\nAn implementation can register an arbitrarily large reservation set on each LR,\nprovided the reservation set includes all bytes of the addressed data word or\ndoubleword.\nAn SC can only pair with the most recent LR in program order.\nAn SC may succeed only if no store from another hart to the reservation set\ncan be observed to have occurred between the LR and the SC,\nand if there is no other SC between the LR and itself in program order.\nAn SC may succeed only if no write from a device other than a hart to the bytes\naccessed by the LR instruction can be observed to have occurred between the LR\nand SC.\nNote this LR might have had a different effective address and data size,\nbut reserved the SC's address as part of the reservation set.\n\n[NOTE]\n----\nFollowing this model, in systems with memory translation, an SC is allowed to succeed if the\nearlier LR reserved the same location using an alias with a different virtual address, but is\nalso allowed to fail if the virtual address is different.\n\nTo accommodate legacy devices and buses, writes from devices other than RISC-V harts are only\nrequired to invalidate reservations when they overlap the bytes accessed by the LR.\nThese writes are not required to invalidate the reservation when they access other bytes in\nthe reservation set.\n----\n\nThe SC must fail if the address is not within the reservation set of the most\nrecent LR in program order.\nThe SC must fail if a store to the reservation set from another hart can be\nobserved to occur between the LR and SC.\nThe SC must fail if a write from some other device to the bytes accessed by the\nLR can be observed to occur between the LR and SC.\n(If such a device writes the reservation set but does not write the bytes accessed\nby the LR, the SC may or may not fail.)\nAn SC must fail if there is another SC (to any address) between the LR and the SC\nin program order.\nThe precise statement of the atomicity requirements for successful LR/SC sequences\nis defined by the Atomicity Axiom of the memory model.\n\n[NOTE]\n--\nThe platform should provide a means to determine the size and shape of the reservation set.\n\nA platform specification may constrain the size and shape of the reservation set.\n\nA store-conditional instruction to a scratch word of memory should be used to forcibly invalidate any existing load reservation:\n\n  * during a preemptive context switch, and\n  * if necessary when changing virtual to physical address mappings, such as when migrating pages that might contain an active reservation.\n\nThe invalidation of a hart's reservation when it executes an LR or SC imply that a hart can only hold one reservation at a time, and that an SC can only pair with the most recent LR, and LR with the next following SC, in program order. This is a restriction to the Atomicity Axiom in Section 18.1 that ensures software runs correctly on expected common implementations that operate in this manner.\n--\n\nAn SC instruction can never be observed by another RISC-V hart before the LR instruction that established the reservation.\n\n[NOTE]\n--\nThe LR/SC sequence can be given acquire semantics by setting the aq bit on the LR instruction. The LR/SC sequence can be given release semantics by by setting the rl bit on the SC instruction. Assuming suitable mappings for other atomic operations, setting the aq bit on the LR instruction, and setting the rl bit on the SC instruction makes the LR/SC sequence sequentially consistent in the C++ memory_order_seq_cst sense. Such a sequence does not act as a fence for ordering ordinary load and store instructions before and after the sequence. Specific instruction mappings for other C++ atomic operations, or stronger notions of \"sequential consistency\", may require both bits to be set on either or both of the LR or SC instruction.\n\nIf neither bit is set on either LR or SC, the LR/SC sequence can be observed to occur before or after surrounding memory operations from the same RISC-V hart. This can be appropriate when the LR/SC sequence is used to implement a parallel reduction operation.\n--\n\nSoftware should not set the _rl_ bit on an LR instruction unless the _aq_ bit is also set.\nLR.rl and SC.aq instructions are not guaranteed to provide any stronger ordering than those\nwith both bits clear, but may result in lower performance.\n"

[format_2-0]
type = "type_2-0"

[format_2-0.repr]
default = "$name$%aqrl% %rd_Register_int%, (%rs1_Register_int%)"

[format_2-0.instructions."lr.w"]
mask = 4193284223
match = 268443695
description = "Loads a word from the address in xs1, places the sign-extended value in xd,\nand registers a _reservation set_  -- a set of bytes that subsumes the bytes in the\naddressed word.\n\n<%- if MXLEN == 64 -%>\nThe 32-bit load result is sign-extended to 64-bits.\n<%- end -%>\n\nThe address in xs1 must be naturally aligned to the size of the operand\n(_i.e._, eight-byte aligned for doublewords and four-byte aligned for words).\n\nIf the address is not naturally aligned, a `LoadAddressMisaligned` exception or an\n`LoadAccessFault` exception will be generated. The access-fault exception can be generated\nfor a memory access that would otherwise be able to complete except for the misalignment,\nif the misaligned access should not be emulated.\n\nAn implementation can register an arbitrarily large reservation set on each LR, provided the\nreservation set includes all bytes of the addressed data word or doubleword.\nAn SC can only pair with the most recent LR in program order.\nAn SC may succeed only if no store from another hart to the reservation set can be\nobserved to have occurred between the LR and the SC, and if there is no other SC between the\nLR and itself in program order.\nAn SC may succeed only if no write from a device other than a hart to the bytes accessed by\nthe LR instruction can be observed to have occurred between the LR and SC. Note this LR\nmight have had a different effective address and data size, but reserved the SC's\naddress as part of the reservation set.\n\n[NOTE]\n----\nFollowing this model, in systems with memory translation, an SC is allowed to succeed if the\nearlier LR reserved the same location using an alias with a different virtual address, but is\nalso allowed to fail if the virtual address is different.\n\nTo accommodate legacy devices and buses, writes from devices other than RISC-V harts are only\nrequired to invalidate reservations when they overlap the bytes accessed by the LR.\nThese writes are not required to invalidate the reservation when they access other bytes in\nthe reservation set.\n----\n\nSoftware should not set the _rl_ bit on an LR instruction unless the _aq_ bit is also set.\nLR.rl and SC.aq instructions are not guaranteed to provide any stronger ordering than those\nwith both bits clear, but may result in lower performance.\n"

[mappings]
names = [
    "Register_int",
    "Register_float",
    "Mapping_ordering",
]
number = 32
Register_int = [
    "zero",
    "ra",
    "sp",
    "gp",
    "tp",
    "t0",
    "t1",
    "t2",
    "s0",
    "s1",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "s2",
    "s3",
    "s4",
    "s5",
    "s6",
    "s7",
    "s8",
    "s9",
    "s10",
    "s11",
    "t3",
    "t4",
    "t5",
    "t6",
]
Register_float = [
    "ft0",
    "ft1",
    "ft2",
    "ft3",
    "ft4",
    "ft5",
    "ft6",
    "ft7",
    "fs0",
    "fs1",
    "fa0",
    "fa1",
    "fa2",
    "fa3",
    "fa4",
    "fa5",
    "fa6",
    "fa7",
    "fs2",
    "fs3",
    "fs4",
    "fs5",
    "fs6",
    "fs7",
    "fs8",
    "fs9",
    "fs10",
    "fs11",
    "ft8",
    "ft9",
    "ft10",
    "ft11",
]
Mapping_ordering = [
    "",
    ".rl",
    ".aq",
    ".aqrl",
]
